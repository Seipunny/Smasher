import{r as U,j as ce}from"./react-CvKGWo5O.js";import{E as le,S as pe,C as he,A as me,V as r,H as de,a as ue,b as G,c as S,M as I,P as a,d as we,e as C,T as W,B as fe,R as ye,f as k,g as ge,h as Z,i as Q,Q as xe}from"./@babylonjs-CKbfzgEg.js";import{C as Ie}from"./cannon-ChDEuZbQ.js";import"./asn1.js-mD9ru2de.js";import"./vite-plugin-node-polyfills-eJnqEgiU.js";import"./inherits-BICa84dG.js";import"./minimalistic-assert-OF9c2MWr.js";import"./vm-browserify-B6h6MQBh.js";const Ne=()=>{const z=U.useRef(null);return U.useEffect(()=>{const E=z.current;if(!E)return;const T=e=>e.preventDefault();document.addEventListener("touchstart",T,{passive:!1}),document.addEventListener("touchmove",T,{passive:!1});const P=new le(E,!0),s=new pe(P);s.clearColor=new he(.141,.141,.141,1);let $=0;const N=10,u=1,y=2,M=4,c=8,J=16,f=new me("camera",Math.PI/4,Math.PI/4,20,new r(0,25,0),s);f.mode=1,f.attachControl(E,!0);const b=10,L=()=>{const e=E.width/E.height,o=b/e;f.orthoLeft=-b,f.orthoRight=b,f.orthoTop=o,f.orthoBottom=-o};window.addEventListener("resize",L),L(),f.lowerRadiusLimit=f.upperRadiusLimit=f.radius;const K=new de("light",new r(Math.sin(Math.PI/18),1,Math.cos(Math.PI/18)),s);K.intensity=1;const Y=new ue(!0,10,Ie);s.enablePhysics(new r(0,-9.81,0),Y);const q=async(e,o)=>{try{const n=await Z.ImportMeshAsync("","./models/","generator.obj");console.log("ImportMeshAsync result:",n);const t=new Q("parentNode",e);t.position=o,t.scaling=new r(2.5,2.5,2.5),n.meshes.forEach((p,ae)=>{console.log(`Imported Mesh ${ae} name: ${p.name}`),p.parent=t});const i=n.meshes.find(p=>p.name==="SM_Bld_Corp_Generator_01_Arms_01");i?(console.log("Found rotating mesh:",i.name),e.registerBeforeRender(()=>{i.addRotation(0,.01,0)})):console.warn("Rotating mesh not found.");const l=n.meshes.find(p=>p.name==="SM_Bld_Corp_Generator_01_Tank_01");l?(console.log("Found rotating mesh:",l.name),e.registerBeforeRender(()=>{l.addRotation(0,-.01,0)})):console.warn("Rotating mesh not found."),console.log("All meshes grouped and placed at position",o)}catch(n){console.error("Error loading mesh:",n)}},X=async(e,o)=>{try{const n=await Z.ImportMeshAsync("","./models/","container.obj");console.log("ImportMeshAsync result:",n);const t=new Q("parentNode",e);t.position=o,t.scaling=new r(4.5,4.5,4.5),n.meshes.forEach((i,l)=>{console.log(`Imported Mesh ${l} name: ${i.name}`),i.parent=t})}catch(n){console.error("Error loading mesh:",n)}},D=(e,o,n)=>{const t=I.CreateBox(e,{width:10,height:1,depth:10},s);t.position.y=o,t.physicsImpostor=new a(t,a.BoxImpostor,{mass:0,restitution:.9},s);const i=new G(`${e}Material`,s);return i.diffuseColor=new S(.5,.5,.5),i.alpha=.5,t.material=i,t.physicsImpostor.physicsBody.collisionFilterGroup=n,t.physicsImpostor.physicsBody.collisionFilterMask=u|y|M|c,t};D("ground",25,M),D("lowerPlatform",20,c),q(s,new r(0,37.3,0)),X(s,new r(0,9.5,0)),(()=>{const e=I.CreateBox("greenBox",{width:1,height:1,depth:10},s);e.position.y=21,e.position.x=-4.5,e.physicsImpostor=new a(e,a.BoxImpostor,{mass:0,restitution:.9},s);const o=new G("greenBoxMaterial",s);o.diffuseColor=new S(0,1,0),e.material=o,e.physicsImpostor.physicsBody.collisionFilterGroup=J,e.physicsImpostor.physicsBody.collisionFilterMask=u|c;let n=1;const t=.05,i=-4.5,l=4.5;s.onBeforeRenderObservable.add(()=>{e.position.x+=n*t,e.position.x>=l?(e.position.x=l,n=-1):e.position.x<=i&&(e.position.x=i,n=1),s.meshes.forEach(p=>{p.name.startsWith("fragment")&&e.intersectsMesh(p,!1)&&(p.dispose(),$+=1,B.text=`Balance: ${$}`)})})})();const ee=()=>{if(s.meshes.filter(o=>o.name==="box"&&!o.isCrushed).length<N){const o=I.CreateBox("box",{size:1},s);o.position=new r(Math.random()*4-2,37,Math.random()*4-2),o.rotation=new r(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI),o.physicsImpostor=new a(o,a.BoxImpostor,{mass:2,restitution:.5},s),o.physicsImpostor.physicsBody.collisionFilterGroup=u|y|M|c,o.physicsImpostor.physicsBody.collisionFilterMask=u|y|M|c,o.isCrushed=!1}},A=(e,o,n,t)=>{const i=I.CreateBox("wall",{width:e,height:o,depth:n},s);i.position=t,i.isVisible=!1,i.physicsImpostor=new a(i,a.BoxImpostor,{mass:0,restitution:.9},s),i.physicsImpostor.physicsBody.collisionFilterGroup=u,i.physicsImpostor.physicsBody.collisionFilterMask=u|y|M|c};A(10,40,1,new r(0,20,-5.5)),A(10,40,1,new r(0,20,5.5)),A(1,40,10,new r(-5.5,20,0)),A(1,40,10,new r(5.5,20,0)),A(10,1,10,new r(0,40,0));const F=new G("pressMaterial",s);F.diffuseColor=new S(0,0,0);const h=I.CreateBox("leftPress",{width:2,height:3,depth:10},s);h.position=new r(-4.5,27,0),h.material=F,h.physicsImpostor=new a(h,a.BoxImpostor,{mass:0,restitution:.9},s),h.physicsImpostor.physicsBody.collisionFilterGroup=y,h.physicsImpostor.physicsBody.collisionFilterMask=u|y|M|c;const m=I.CreateBox("rightPress",{width:2,height:3,depth:10},s);m.position=new r(4.5,27,0),m.material=F,m.physicsImpostor=new a(m,a.BoxImpostor,{mass:0,restitution:.9},s),m.physicsImpostor.physicsBody.collisionFilterGroup=y,m.physicsImpostor.physicsBody.collisionFilterMask=u|y|M|c;let R=!1;const oe=e=>{const n=I.CreateBox("fragment1",{size:.5},s);n.position=new r(e.x-.25,e.y,e.z),n.physicsImpostor=new a(n,a.BoxImpostor,{mass:1,restitution:.5},s),n.physicsImpostor.physicsBody.collisionFilterGroup=c,n.physicsImpostor.physicsBody.collisionFilterMask=u|c;const t=I.CreateBox("fragment2",{size:.5},s);t.position=new r(e.x+.25,e.y,e.z),t.physicsImpostor=new a(t,a.BoxImpostor,{mass:1,restitution:.5},s),t.physicsImpostor.physicsBody.collisionFilterGroup=c,t.physicsImpostor.physicsBody.collisionFilterMask=u|c;const i=l=>{if(l.physicsImpostor){const p=new r((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2).normalize().scale(10);l.physicsImpostor.applyImpulse(p,l.getAbsolutePosition())}};i(n),i(t)},V=()=>{s.meshes.forEach(e=>{const o=e;o.name==="box"&&!o.isCrushed&&o.intersectsMesh(h,!1)&&o.intersectsMesh(m,!1)&&(oe(o.position),o.isCrushed=!0,o.dispose())})},se=()=>{if(h.position.x===-4.5&&m.position.x===4.5){if(R)return;R=!0;const e=.1,o=10,n=Math.abs(-4.5- -.75)/e;let t=0;const i=setInterval(()=>{t<n?(h.position.x+=e,m.position.x-=e,t++,V()):t<2*n?(h.position.x-=e,m.position.x+=e,t++,V()):(clearInterval(i),h.position=new r(-4.5,27,0),m.position=new r(4.5,27,0),R=!1)},o)}},O=we.CreateFullscreenUI("UI"),d=new C;d.width="200px",d.height="100px",d.horizontalAlignment=C.HORIZONTAL_ALIGNMENT_LEFT,d.verticalAlignment=C.VERTICAL_ALIGNMENT_TOP,d.isVertical=!0,d.top="10px",d.left="10px",O.addControl(d);const B=new W;B.text="Balance: 0",B.color="white",B.fontSize=24,B.width="200px",B.height="40px",d.horizontalAlignment=C.HORIZONTAL_ALIGNMENT_CENTER,d.addControl(B);const g=new W;g.text=`0/${N}`,g.color="white",g.fontSize=24,g.width="200px",g.height="40px",g.paddingTop="10px",d.addControl(g);const x=new C;x.width="100%",x.height="50px",x.horizontalAlignment=C.HORIZONTAL_ALIGNMENT_CENTER,x.verticalAlignment=C.VERTICAL_ALIGNMENT_BOTTOM,x.isVertical=!1,x.paddingBottom="10px",O.addControl(x);const v=fe.CreateSimpleButton("pressButton","Press");v.width="150px",v.height="40px",v.color="white",v.background="black",v.onPointerDownObservable.add(()=>{se()}),x.addControl(v);const te=setInterval(ee,1e3),ne=()=>{const e=s.meshes.filter(o=>o.name==="box"&&!o.isCrushed).length;g.text=`${e}/${N}`},ie=()=>{s.meshes.forEach(e=>{const o=e;o.name==="box"&&!o.isCrushed&&e.position.y<=24&&o.dispose()})};P.runRenderLoop(()=>{s.render(),ie(),ne()});const j=()=>{P.resize(),L()};window.addEventListener("resize",j);const w=new ye("splashScreen");w.width="100%",w.height="100%",w.background="#242424",w.alpha=1,w.thickness=0,O.addControl(w);const _=new k("fadeOut","alpha",60,k.ANIMATIONTYPE_FLOAT,k.ANIMATIONLOOPMODE_CONSTANT),re=[{frame:0,value:1},{frame:120,value:0}];_.setKeys(re);const H=new xe;return H.setEasingMode(ge.EASINGMODE_EASEINOUT),_.setEasingFunction(H),w.animations=[],w.animations.push(_),s.beginAnimation(w,0,120,!1,1,()=>{w.dispose()}),()=>{clearInterval(te),P.dispose(),window.removeEventListener("resize",j),window.removeEventListener("resize",L),document.removeEventListener("touchstart",T),document.removeEventListener("touchmove",T)}},[]),ce.jsx("canvas",{ref:z,style:{width:"100vw",height:"100vh"},tabIndex:-1})};export{Ne as default};
